/*
 * 城情報型 及び、 城付加情報型
 */
#pragma once
#pragma pack(1)

#include <windows.h>

using namespace std;

/*
			城情報(33*214)

			[33バイト]

			0-1		軍団所属リストの前
			2-3		リストの後ろ
			4-5		城主
			6-7		浪人先頭
			8-16	城名
			17-18	所属	所属軍団の軍団番号
			19		城郭
			20-21	石高
			22		商業
			23-24	人口-徴兵可
			25		民忠
			26-27	徴兵可
			28		兵質 0-2
			29		ABC0 EFGH
					A 一揆 B 国際港 C 港 E 馬産地 F 鍛冶 G 本城 H 居城
			30		ABCD EFGH
					C 一揆扇動 G 金山 H 銀山
			31		AAAAAA BB
					A:城称	0x00 城 0x01 御坊 0x02 寺 0x04 御所 0x08 館 0x10 町 0x20 城、それ以外の値=何も付かない
					B:｢絵｣を表示した時の、背景の種類(0=山) (1=林) (2=海) (3=平野)
			32		000A000B A-巨城 B 名前変更
*/
struct 城情報型
{
	WORD 前の城【城番号】;			// あまり使うことはない  軍団所属城リスト 前の城
	WORD 次の城【城番号】;			// とくに使うことはない  軍団所属城リスト 後の城
	WORD 城主【武将番号】;			// 城主
	WORD _浪人先頭武将【武将番号】;	// あまり使うことはない

	char _城名[9];				//城名
	WORD 所属軍団【軍団番号】;	//所属軍団番号
	byte 城郭;			//城郭
	WORD 石高;			//石高
	byte 商業;			//商業
	WORD 人口;			//人口
	byte 民忠;			//民忠
	WORD 徴兵可;		//徴兵可

	byte 兵質;			//兵質 0-2
	byte _未定義0:2;	//本城 居城
	byte 鍛冶:1;		//鍛冶
	byte 馬産地:1;		//馬産地
	byte _未定義3:1;	//0
	byte 港:1;			//港
	byte 国際港:1;		//国際港
	byte _未定義4:1;	//
	byte 銀山:1;		//銀山
	byte 金山:1;		//金山
	byte _未定義5:2;	//
	byte 一騎煽動:1;	//一揆扇動
	byte _未定義6:3;	//

	byte 城絵背景:2;	//｢絵｣を表示した時の、背景の種類 城称(0=山) (1=林) (2=海) (3=平野)
	byte _城称:6;		//城称 2012/06/15 天翔記.jp ここはほぼ判明しているが、完全ではないので現在は情報IO実装は保留としておく。
	byte _未定義7:3;	//
	byte 巨城:1;		//巨城
	byte _名前変更:4;	//あまり使うことはない 名前変更 シナリオエディタか何かに詳しく説明があったようななかったような…
};


namespace 関数 {


	// 城名を取得する
	string Get_城名( int 城番号【配列用】);

	// 城名を設定する
	void   Set_城名( int 城番号【配列用】, string 城名 );



}


// 値比較用
namespace 城絵背景 {
	enum { 山=0, 林=1, 海=2, 平野=3 };
};




/*
			城の位置情報など(8*214)

			[8バイト]

			0	地域名
			1	0
			2	石高最大値/10
			3	商業最大値
			4	Xセル座標(マップで見えてるのとは異なる区切り方 50個で区切られている)
			5	Yセル座標(上と同じで、マップで見えているのとは異なる区切り方12個程度で区切られている)
			6	X_offset
			7	Y_offset
*/
struct 城付加情報型
{
    byte 所属地域【地域番号】;	//地域名
	byte _未定義1;			//must 0
	byte 最大石高÷10;		//最石高÷10
	byte 最大商業値;		//最商業
	byte _Ｘ情報;			//やや不透明。セルX関連の情報    Ｘは３違いぐらいでも隣接していることがある。２以下は確実に隣接している。
	byte _Ｙ情報;			//やや不透明。セルY関連の情報	 Ｙは２以下なら隣接している。
	byte Ｘ位置;			//城のＸ位置。この情報はかなり固い。グリッドマップを導入すればよくわかる。グリッド内のＸ幅は？？
	byte Ｙ位置;			//城のＹ位置。この情報はかなり固い。グリッドマップを導入すればよくわかる。グリッド内のＹ幅は３．
};


namespace 関数 {
	void Set_城位置(int 城番号【配列用】, int Ｘ位置, int Ｙ位置);
}